 cd c:\Users\TOSHIBA\Desktop\hol_light
 ocamlc -c -pp "camlp4r pa_extend.cmo q_MLast.cmo" -I +camlp4 pa_j.ml 
 ocaml
 #use "hol.ml";;


g `!(a:bool) (b:bool). ((a /\ b) \/ (~a /\ b)) = (b)`;;
e(REPEAT GEN_TAC);;
e(REPEAT_TAC [GSYM RIGHT_OR_DISTRIB]);;
e(REWRITE_TAC [EXCLUDED_MIDDLE]);;
let this_theo = top_thm();;
search [`x /\ y \/ z /\ y`];;
search [` &1 <= x pow n `];;
search [` 2*(x:num)`];;






g` FST (SND (EL 1 [s1,g1,e1; s2,e2,g2])) = p`;;
`FST (SND (EL 1 [s1,g1,e1; s2,e2,g2])) = p`
e(REWRITE_TAC[ONE;EL;TL;HD;SND;FST]);;
let THREE = prove (`3  = SUC 2 `, ARITH_TAC);;
let FOUR = prove (`4  = SUC 3 `, ARITH_TAC);;
e(REWRITE_TAC [my_listt_def ; APPEND ; EL ; HD ; TWO; ONE; THREE; FOUR; TL]);;






ANTS_TAC
strips a function application from both sides of an equality
AP_TERM_TAC
apply f on x if f is not defined in x apply g
applyd f g x 
e ARITH_TAC;;
e ASM_ARITH_TAC;;
to simplify the assumption 
e STRIP_TAC;;
to study the goal in the both cases : [`~(&0 <= u)`]  and [`&0 <= u`]
e(ASM_CASES_TAC `&0 <= u`);;
e(CONV_TAC ARITH_RULE) ;;




g `!(x:num) (y:num) (m:num). x <= y /\ x <= m ==> (x <= y + m) `;;
e(REPEAT GEN_TAC);;
e(DISCH_TAC);;
e(MATCH_MP_TAC LE_TRANS);;
e(EXISTS_TAC `((x:num)+x)`);;
e(CONJ_TAC);;
e(DISCH_TAC);;
e(CONV_TAC ARITH_RULE);;
e(MATCH_MP_TAC LE_ADD2);;
e(ONCE_ASM_REWRITE_TAC[]);;
e(ASM_REWRITE_TAC[]);;







let my_fac_def = define `(my_fac 0 = 1) /\ (my_fac (SUC n) = (SUC n) * (my_fac n))`;;


g ` !(n:num). (0 < my_fac n)`;;
 e(MATCH_MP_TAC num_INDUCTION);;
 e(REWRITE_TAC [my_fac_def]);;
 e(CONV_TAC ARITH_RULE);;
let my_fac = top_thm();;







g `!(n:num). (n <= my_fac n)`;;
e(MATCH_MP_TAC num_INDUCTION);;
 e(REWRITE_TAC [my_fac_def]);;
 e(CONJ_TAC);;
e ARITH_TAC;;
e(GEN_TAC THEN DISCH_TAC);;
 















e(SUBGOAL_THEN `SUC n = (SUC n)*1` ASSUME_TAC);;
 e ARITH_TAC;;
e(ONCE_ASM_REWRITE_TAC[]);;
search [` (a:num) * b <= c * d `];;
e(MATCH_MP_TAC LE_MULT2);;
 e(CONJ_TAC);;
e ARITH_TAC;;
 e(SUBGOAL_THEN `!n. 1 <= my_fac n` ASSUME_TAC);;
e INDUCT_TAC;;
 e(REWRITE_TAC [my_fac_def]);;
 e ARITH_TAC ;;
e(REWRITE_TAC [my_fac_def]);;
e(SUBGOAL_THEN `1=1*1 ` ASSUME_TAC);;
 e(ONCE_ASM_REWRITE_TAC[]);;
e(CONV_TAC ARITH_RULE);;
  e(ONCE_ASM_REWRITE_TAC[]);;
 e(MATCH_MP_TAC LE_MULT2);;
 e(ONCE_ASM_REWRITE_TAC[]);;
 e(CONV_TAC ARITH_RULE);;
 e(ONCE_ASM_REWRITE_TAC[]);;





g `!(a:real) (b:real). (a*b) + (--a*b) = &0`;;
e(REPEAT GEN_TAC);;
search [` (x:real)*y + z*y ` ];;
e(REWRITE_TAC [GSYM REAL_ADD_RDISTRIB]);;
 e(REWRITE_TAC [REAL_ADD_RINV]);;
e REAL_ARITH_TAC ;;




g ` !(n:num) (x:real). (&1 <= x) ==> ( x <= x pow (SUC n))` ;;
 e(REPEAT GEN_TAC THEN DISCH_TAC);;
search [` (x:real) pow (n:num)`];;
 e(REWRITE_TAC [real_pow]);;
e(SUBGOAL_THEN ` (x <= x * x pow n) = x * (&1) <= x * x pow n ` ASSUME_TAC);;
e REAL_ARITH_TAC ;;
 e(ONCE_ASM_REWRITE_TAC[]);;
search [` (a:real) * b  <= c * d`];;
 e(MATCH_MP_TAC REAL_LE_MUL2);;
 e(ONCE_ASM_REWRITE_TAC[]);;
e(REPEAT STRIP_TAC);;
 e(ONCE_ASM_REWRITE_TAC[]);;
search [` &0 <= (x:real)`];;
 e( ASM_REAL_ARITH_TAC) ;;
 e( ASM_REAL_ARITH_TAC) ;;
 e( ASM_REAL_ARITH_TAC) ;;
search [` (x:real) pow (n:num)`];;
e(MATCH_MP_TAC REAL_POW_LE_1);;
e( ASM_REAL_ARITH_TAC) ;;
















let g1_def = define ` (g1 [] b = F ) /\ (g1 (CONS a t) b = if(a=b) then T else g1 t b)`;;

let dd1_def = define ` (dd1 a [] = F ) /\ (dd1 a (CONS b t) = if(a=b) then T else dd1 a t)`;;
let ff_main_def = define ` (ff_main [] [] = F) /\ ( ff_main (CONS a t1) (CONS b t2) = if((g1 (CONS a t1) b) \/ (dd1 a (CONS b t2))) then T else ff_main t1 t2)`;;
g ` ff_main [1;2;3] [2;4;5] = T`;;
e(REWRITE_TAC [ff_main_def; dd1_def; g1_def ; ARITH_RULE `~(2=4)`]);;
e(SIMP_TAC [ARITH_RULE `~(2=4)`; ARITH_RULE `~(1=2)`; ARITH_RULE `~(1=4)`;ARITH_RULE `~(1=5)`;ARITH_RULE `~(2=5)`; ARITH_RULE `~(3=4)`;ARITH_RULE `~(3=5)`;    ]);;

g` FST (SND (EL 1 [s1,g1,e1; s2,e2,g2])) = p`;;
`FST (SND (EL 1 [s1,g1,e1; s2,e2,g2])) = p`
e(REWRITE_TAC[ONE;EL;TL;HD;SND;FST]);;
let THREE = prove (`3  = SUC 2 `, ARITH_TAC);;
let FOUR = prove (`4  = SUC 3 `, ARITH_TAC);;
e(REWRITE_TAC [my_listt_def ; APPEND ; EL ; HD ; TWO; ONE; THREE; FOUR; TL]);;




 let gain_list_def = define `(gain_list [] = 0) /\ (gain _list [s1,g1,e1] = g1) /\ (gain_list t =  (FST (SND ( HD t))) *( gain_list (TL t)) )`;;



let gain_list_def = define `(gain_list [] = 0) /\ (gain _list [s1,g1,e1] = FST (SND [s1,g1,e1])) /\ (gain_list (CONS [s1,g1,e1] t) =  (FST (SND [s1,g1,e1])) *( gain_list t) )`;;


let gain_cl = define `(gain_cl [] = (&0)) /\ (gain_cl [(h:real#real#real)] = (FST (SND (h))))`;;
val gain_cl : thm = |- gain_cl [] = &0 /\ gain_cl [h] = FST (SND h)


 let gain_cal = define `(gain_cal [] = (&0))  /\ (gain_cal (CONS (h:real#real#real) t) =  (FST (SND (h))) * (gain_cal t) )`;;
val gain_cal : thm =
  |- gain_cal [] = &0 /\ gain_cal (CONS h t) = FST (SND h) * gain_cal t



let gain_mul_def = define `(gain_mul [] = (&1))  /\ (gain_mul (CONS (h:real#real#real) t) =  (FST (SND (h))) * (gain_mul t) )`;;
g ` (gain_mul ([&1,&2,&3;&4,&5,&6;&7,&8,&9])) = (&80) `;;
e(REWRITE_TAC [gain_mul_def]);;
e REAL_ARITH_TAC;;






let gg1_def = define ` (gg1 [] b = F ) /\ (gg1 (CONS a t) b = if((SND (SND a)= FST b) \/ (SND (SND b)= FST a) \/ (SND (SND a)= SND (SND b)) \/ (FST a = FST b)) then T else gg1 t b)`;;
let ddd1_def = define ` (ddd1 a [] = F ) /\ (ddd1 a (CONS b t) = if((SND (SND a)= FST b) \/ (SND (SND b)= FST a) \/ (SND (SND a)= SND (SND b)) \/ (FST a = FST b)) then T else ddd1 a t)`;;
 let fff_main_def = define ` (fff_main [] [] = F) /\ ( fff_main (CONS a t1) (CONS b t2) = if((gg1 (CONS a t1) b) \/ (ddd1 a (CONS b t2))) then T else fff_main t1 t2)`;;
e(REWRITE_TAC [fff_main_def; ddd1_def; gg1_def ; SND ; FST] );;







--------------------------------------*****************----------------

 let ggg1_def = define ` (ggg1 [] b = F ) /\ (ggg1 (CONS a (t: (real#real#real) list)) b = if((SND (SND a)= FST b) \/ (SND (SND b)= FST a) \/ (SND (SND a)= SND (SND b)) \/ (FST a = FST b)) then T else ggg1 t b)`;;




let dddd1_def = define ` (dddd1 a [] = F ) /\ (dddd1 a (CONS b (t: (real#real#real) list)) = if((SND (SND a)= FST b) \/ (SND (SND b)= FST a) \/ (SND (SND a)= SND (SND b)) \/ (FST a = FST b)) then T else dddd1 a t)`;;



let fgd_main_def = define ` (fgd_main [] [] = F) /\ ( fgd_main (CONS a (t1: (real#real#real) list)) (CONS b (t2: (real#real#real) list)) = if((ggg1 (CONS a t1) b) \/ (dddd1 a (CONS b t2))) then T else fgd_main t1 t2)`;;


let ffffg_main_def = define ` (ffffg_main (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = if(fgd_main t1 t2) then (if (fgd_main t1 t3) then (if (fgd_main t2 t3)  then (&0) else ((gain_mul t2)*(gain_mul t3))) else (if (fgd_main t2 t3)  then ((gain_mul t1)*(gain_mul t3)) else ((gain_mul t1)*(gain_mul t3) + (gain_mul t2)*(gain_mul t3)))) else (if (fgd_main t1 t3) then (if (fgd_main t2 t3)  then ((gain_mul t1)*(gain_mul t2)) else ((gain_mul t2)*(gain_mul t3) + (gain_mul t1)*(gain_mul t2))) else (if (fgd_main t2 t3)  then ((gain_mul t1)*(gain_mul t3) + (gain_mul t1)*(gain_mul t2)) else ((gain_mul t1)*(gain_mul t3) + (gain_mul t2)*(gain_mul t3) + (gain_mul t1)*(gain_mul t2) - (gain_mul t1)*(gain_mul t2)*(gain_mul t3)) )))`;;



let ffffgg_main_def = define ` (ffffgg_main (t: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = if(fgd_main t t2) then (if (fgd_main t t3) then  (&0) else  (gain_mul t3) ) else (if (fgd_main t t3) then (gain_mul t2) else (if (fgd_main t2 t3)  then ((gain_mul t3) + (gain_mul t2)) else ((gain_mul t3) - (gain_mul t2)*(gain_mul t3) + (gain_mul t2) ) )))`;;



 let ffffgggg_main_def = define ` (ffffgggg_main (t: (real#real#real) list) (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = if(fgd_main t t1) then (ffffgg_main t t2 t3) else (if (fgd_main t t3) then (ffffgg_main t t2 t1)  else (if (fgd_main t t2) then (ffffgg_main t t1 t3)  else ((gain_mul t1) + (gain_mul t3) + (gain_mul t2) - (ffffg_main t1 t2 t3) ) )))`;;


let gain_calculation_def = define ` (gain_calculation (l1: (real#real#real) list) (l2: (real#real#real) list) (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = (((gain_mul l1) * ((&1) -  (ffffgggg_main l1 t1 t2 t3)) + (gain_mul l2) * ((&1) -  (ffffgggg_main l2 t1 t2 t3))) / ((&1) - (gain_mul t1) - (gain_mul t2) - (gain_mul t3) + (ffffgg_main t1 t2 t3))) )`;;
---------------************************------------------------------------


g `gain_calculation [&1,&2,&3;&3,&2,&4;&4,&2,&5] [&1,&2,&6;&6,&2,&5] [&7,&2,&8;&8,&2,&7] [&7,&2,&7] [&9,&2,&4;&4,&2,&9] = &5 `;;
e(REWRITE_TAC [gain_calculation_def; ffffgggg_main_def; ffffgg_main_def; ffffg_main_def ; fgd_main_def; dddd1_def; ggg1_def ; SND ; FST] );;


--------------------------******************---------------
 let gain_mul_def = define `(gain_mul [] = (&1))  /\ (gain_mul (CONS (h:real#real#real) t) =  (FST (SND (h))) * (gain_mul t) )`;;

 let gain_def = define ` (gain (t: (real#real#real) list) = if(t=[]) then (&0) else (gain_mul t) )`;;

 let d_def = define ` (d a [] = F ) /\ (d a (CONS b (t: (real#real#real) list)) = if((SND (SND a)= FST b) \/ (SND (SND b)= FST a) \/ (SND (SND a)= SND (SND b)) \/ (FST a = FST b)) then T else d a t)`;;

 let g_def = define ` (g [] b = F ) /\ (g (CONS a (t: (real#real#real) list)) b = if((SND (SND a)= FST b) \/ (SND (SND b)= FST a) \/ (SND (SND a)= SND (SND b)) \/ (FST a = FST b)) then T else g t b)`;;

 let fgd_main_def = define ` (fgd_main [] [] = F) /\ (fgd_main [] (t1: (real#real#real) list) = F) /\ (fgd_main (t2: (real#real#real) list) [] = F) /\ ( fgd_main (CONS a (t1: (real#real#real) list)) (CONS b (t2: (real#real#real) list)) = if((g (CONS a t1) b) \/ (d a (CONS b t2))) then T else fgd_main t1 t2)`;;

let loop_main_def = define ` (loop_main (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = if(fgd_main t1 t2) then (if (fgd_main t1 t3) then (if (fgd_main t2 t3)  then (&0) else ((gain t2)*(gain t3))) else (if (fgd_main t2 t3)  then ((gain t1)*(gain t3)) else ((gain t1)*(gain t3) + (gain t2)*(gain t3)))) else (if (fgd_main t1 t3) then (if (fgd_main t2 t3)  then ((gain t1)*(gain t2)) else ((gain t2)*(gain t3) + (gain t1)*(gain t2))) else (if (fgd_main t2 t3)  then ((gain t1)*(gain t3) + (gain t1)*(gain t2)) else ((gain t1)*(gain t3) + (gain t2)*(gain t3) + (gain t1)*(gain t2) - (gain t1)*(gain t2)*(gain t3)) )))`;;


let forward_main_def = define ` (forward_main (t: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = if(fgd_main t t2) then (if (fgd_main t t3) then  (&0) else  (gain t3) ) else (if (fgd_main t t3) then (gain t2) else (if (fgd_main t2 t3)  then ((gain t3) + (gain t2)) else ((gain t3) - (gain t2)*(gain t3) + (gain t2) ) )))`;;


let path_main_def = define ` (path_main (t: (real#real#real) list) (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = if(fgd_main t t1) then (forward_main t t2 t3) else (if (fgd_main t t3) then (forward_main t t2 t1)  else (if (fgd_main t t2) then (forward_main t t1 t3)  else ((gain t1) + (gain t3) + (gain t2) - (loop_main t1 t2 t3) ) )))`;;


let fpath_main_def = define ` (fpath_main (t: (real#real#real) list) (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = if(fgd_main t t1) then (forward_main t t2 t3) else (if (fgd_main t t3) then (forward_main t t2 t1)  else (if (fgd_main t t2) then (forward_main t t1 t3)  else ((gain t1) + (gain t3) + (gain t2) - (loop_main t1 t2 t3) ) )))`;;


let gain_calculation_def = define ` (gain_calculation (l1: (real#real#real) list) (l2: (real#real#real) list) (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = (((gain l1) * ((&1) -  (fpath_main l1 t1 t2 t3)) + (gain l2) * ((&1) -  (fpath_main l2 t1 t2 t3))) / ((&1) - (gain t1) - (gain t2) - (gain t3) + (loop_main t1 t2 t3))) )`;;



---------------------************************------------------------------


e(REWRITE_TAC [gain_calculation_def; gain_mul_def; gain_def; d_def; g_def; fgd_main_def; loop_main_def; path_main_def; forward_main_def; fpath_main_def; SND ; FST] );;
e(REWRITE_TAC [ ARITH_RULE `~((&3)=(&7))`]);;
e(REWRITE_TAC [ ARITH_RULE `~((&3)=(&7))`; ARITH_RULE `~((&8)=(&1))`; ARITH_RULE `~((&3)=(&8))`; ARITH_RULE `~((&1)=(&7))`; ARITH_RULE `~((&4)=(&7))`; ARITH_RULE `~((&4)=(&8))`; ARITH_RULE `~((&5)=(&7))`; ARITH_RULE `~((&5)=(&8))` ]);;
e(REWRITE_TAC [ ARITH_RULE `~((&3)=(&9))`; ARITH_RULE `~((&4)=(&1))`; ARITH_RULE `~((&3)=(&4))`; ARITH_RULE `~((&1)=(&9))`; ARITH_RULE `~((&8)=(&9))`; ARITH_RULE `~((&7)=(&9))`; ARITH_RULE `~((&6)=(&7))`; ARITH_RULE `~((&6)=(&8))`; ARITH_RULE `~((&6)=(&9))`; ARITH_RULE `~((&6)=(&4))` ]);;
e(REWRITE_TAC [ ARITH_RULE `~((&5)=(&9))`; ARITH_RULE `~((&5)=(&4))`]);;



----------------------****************************---------------------------
let gain_mul_def = define `(gain_mul [] = (&1))  /\ (gain_mul (CONS (h:real#real#real) t) =  (FST (SND (h))) * (gain_mul t) )`;;





 let gain_def = define ` (gain (t: (real#real#real) list) = if(t=[]) then (&0) else (gain_mul t) )`;;

 let d_def = define ` (d a [] = F ) /\ (d a (CONS b (t: (real#real#real) list)) = if((SND (SND a)= FST b) \/ 
(SND (SND b)= FST a) \/ (SND (SND a)= SND (SND b)) \/ (FST a = FST b)) then T else d a t)`;;

 let g_def = define ` (g [] b = F ) /\ (g (CONS a (t: (real#real#real) list)) b = if((SND (SND a)= FST b) \/ (SND (SND b)= FST a) \/ (SND (SND a)= SND (SND b)) \/ (FST a = FST b)) then T else g t b)`;;

 let fgd_main_def = define ` (fgd_main [] [] = F) /\ (fgd_main [] (t1: (real#real#real) list) = F) /\ (fgd_main (t2: (real#real#real) list) [] = F) /\ ( fgd_main (CONS a (t1: (real#real#real) list)) (CONS b (t2: (real#real#real) list)) = if((g (CONS a t1) b) \/ (d a (CONS b t2))) then T else fgd_main t1 t2)`;;

let loop3_main_def = define ` (loop3_main (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = if(fgd_main t1 t2) then (if (fgd_main t1 t3) then (if (fgd_main t2 t3)  then (&0) else ((gain t2)*(gain t3))) else ((gain t1)*(gain t3) + (if (fgd_main t2 t3)  then (&0) else ((gain t2)*(gain t3))))) else ((gain t1)*(gain t2) + (if (fgd_main t1 t3) then (if (fgd_main t2 t3)  then (&0) else ((gain t2)*(gain t3))) else ((gain t1)*(gain t3) + (if (fgd_main t2 t3)  then (&0) else ((gain t2)*(gain t3) - (gain t1)*(gain t2)*(gain t3)))))))`;;

let loop4_main_def = define ` (loop4_main (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) (t4: (real#real#real) list) = (loop3_main t2 t3 t4) + (if(fgd_main t1 t2) then (if (fgd_main t1 t3) then (if (fgd_main t1 t4)  then (&0) else ((gain t1)*(gain t4))) else ((gain t1)*(gain t3) + (if (fgd_main t1 t4)  then (&0) else ((gain t1)*(gain t4) + (if (fgd_main t3 t4) then (&0) else ((&0) - (gain t1)*(gain t4)*(gain t3))))))) else ((gain t1)*(gain t2) + (if (fgd_main t1 t3) then (if (fgd_main t1 t4)  then (&0) else (if(fgd_main t2 t4) then ((gain t1)*(gain t4)) else ((gain t1)*(gain t4) - (gain t1)*(gain t4)*(gain t2)))) else ((gain t1)*(gain t3) + (if (fgd_main t1 t4)  then ( if (fgd_main t2 t3) then (&0) else ((&0) - (gain t1)*(gain t3)*(gain t2))) else ((gain t1)*(gain t4) - (gain t1)*(loop3_main t2 t3 t4))))))))`;;

let forward_main_def = define ` (forward_main (t: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = if(fgd_main t t2) then (if (fgd_main t t3) then  (&0) else  (gain t3) ) else (if (fgd_main t t3) then (gain t2) else (if (fgd_main t2 t3)  then ((gain t3) + (gain t2)) else ((gain t3) - (gain t2)*(gain t3) + (gain t2) ) )))`;;


let path_main_def = define ` (path_main (t: (real#real#real) list) (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) = if(fgd_main t t1) then (forward_main t t2 t3) else (if (fgd_main t t3) then (forward_main t t2 t1)  else (if (fgd_main t t2) then (forward_main t t1 t3)  else ((gain t1) + (gain t3) + (gain t2) - (loop3_main t1 t2 t3) ) )))`;;

let path4_main_def = define ` (path4_main (t: (real#real#real) list) (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) (t4: (real#real#real) list) = if(fgd_main t t1) then (path_main t t2 t3 t4) else (if (fgd_main t t2) then (path_main t t1 t3 t4)  else (if (fgd_main t t3) then (path_main t t1 t2 t4)  else (if (fgd_main t t4) then (path_main t t1 t2 t3)  else ((gain t1) + (gain t3) + (gain t2) +  (gain t4)  - (loop4_main t1 t2 t3 t4))))))`;;


let gain_calculation_def = define ` (gain_calculation (l1: (real#real#real) list) 
(l2: (real#real#real) list) (t1: (real#real#real) list) (t2: (real#real#real) list) (t3: (real#real#real) list) (t4: (real#real#real) list) = (((gain l1) * ((&1) -  (path4_main l1 t1 t2 t3 t4)) + (gain l2) * ((&1) -  (path4_main l2 t1 t2 t3 t4))) / ((&1) - (gain t1) - (gain t2) - (gain t3) - (gain t4) + (loop4_main t1 t2 t3 t4))) )`;;
------------------*******************************-------------------------------
let lop = define  `lop1 a G1 b G2 c G3 d G4 h = [a,G1,b;b,G2,c;c,G3,d;d,G4,h]` ;;
let lop2 = define  `lop2 a G5 ee G6 f G7 gg G8 h = [a,G5,ee;ee,G6,f;f,G7,gg;gg,G8,h]` ;;
let lop4 = define  `lop4 b G2 c H2 = [b,G2,c;c,H2,b]` ;;
let lop5 = define  `lop5 c G3 d H3 = [c,G3,d;d,H3,c]` ;;
 let lop6 = define  `lop6 ee G6 f H6 = [ee,G6,f;f,H6,ee]` ;;
let lop7 = define  `lop7 f G7 gg H7 = [f,G7,gg;gg,H7,f]` ;;


let Loop1 = define  `Loop1 a G1 b G2 c G3 d G4 h = [a,G1,b;b,G2,c;c,G3,d;d,G4,h] ` ;
let Loop2 = define 






g `gain_calculation [a,G1,b;b,G2,c;c,G3,d;d,G4,h] [a,G5,ee;ee,G6,f;f,G7,gg;gg,G8,h] [b,G2,c;c,H2,b] [c,G3,d;d,H3,c] [ee,G6,f;f,H6,ee] [f,G7,gg;gg,H7,f] = (G1*G2*G3*G4*((&1) - G6*H6 - G7*H7) + G5*G6*G7*G8*((&1) - G2*H2 - G3*H3)) / ((&1) - G2*H2 - G3*H3 - G6*H6 - G7*H7 + G2*H2*G6*H6 + G2*H2*G7*H7 + G3*H3*G6*H6 + G3*H3*G7*H7)` ;;